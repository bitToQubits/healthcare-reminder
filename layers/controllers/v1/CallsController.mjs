import { 
    triggerVoiceCall, 
    leaveVoiceMail, 
    receiveVoiceCall, 
    getAllVoiceCalls as getVoiceCalls,
    generateVoiceTTS,
    changeStatusVoiceCall
} from '../../services/v1/CallsService.mjs';
import { streamToArrayBuffer } from '../../../utils/dataConversions.mjs';
import { isJsonString } from '../../../utils/dataValidation.mjs';
import { wait } from '../../../utils/miscellaneous.mjs';
import { Readable } from 'stream';
import constants from '../../../utils/constants.mjs';
import { LiveTranscriptionEvents, createClient as createClientDeepgram } from "@deepgram/sdk";

/* 
    TO-DO: 
    webhook en twilio, que las llamadas se actualizen sola cuando ya este en queue. Que twilio llame a nuestra api.
    manage better the asyncronous and syncronous calls, 
    error handling, 
    streaming of elevenlabs, 
    readme, 
    unit testing, 
    check for requirements,
    check the status for the calls, manage that edge cases.
*/

/**
 * Handle an outbound voice call using Twilio API.
 * @category CallsController
 * @author jlbciriaco[at]gmail.com
 * @param  {Number} phone_number    The phone number to call.
 * @return {Response}               The status for the voice call.
 */
export const makeCall = async (req, res) => {
    let phoneNumber = req.body.phone_number;
    let response = {};

    if (
        typeof phoneNumber != "string" || 
        phoneNumber.trim() == ""
    ) {
        response = {
            "status": false,
            "message": "Please specify a valid phone number."
        }
        res.status(400).json(response);
        return;
    }

    phoneNumber = phoneNumber.trim();

    response = await triggerVoiceCall(phoneNumber);
    res.status(201).json(response);
};

/**
 * Leave a voice mail if machine responds to a Twilio-initiated voice call.
 * @category CallsController
 * @author jlbciriaco[at]gmail.com
 * @param  {String} CallSid     A unique identifier generated by Twilio for this call
 * @param  {String} AccountSid  Twilio account ID
 * @param  {String} AnsweredBy  The result of Twilio algorithm for detecting machines in voice calls
 * @return {Response}           The status for the voice mail
 */
export const sendVoiceMail = async (req, res) => {
    let { CallSid, AccountSid, AnsweredBy } = req.body;
    let response = {};

    if (AccountSid != constants.ACCOUNT_SID_TWILIO) {
        response = {
            "status": false,
            "message": "Must provide a valid account SID for this service."
        }
        res.status(400).json(response);
        return;
    }

    response = await leaveVoiceMail(CallSid, AnsweredBy);
    res.status(201).json(response);
}

/**
 * Status callback for a change in a Twilio voice call status. 
 * @category CallsController
 * @author jlbciriaco[at]gmail.com
 * @param  {Object} CallResource    The twilio response. Get more info at https://static1.twilio.com/docs/voice/api/call-resource 
 * @return {XMLDocument}            The status change for the voice call.
 */
export const handleStatusChange = async (req, res) => {
    const callInfo = req.body;
    const accountSid = req.body.AccountSid;
    let response = {};

    if (accountSid != constants.ACCOUNT_SID_TWILIO) {
        response = {
            "status": false,
            "message": "Must provide a valid account SID for this service."
        }
        res.status(400).json(response);
        return;
    }

    await wait(2000); //Lets give the Twilio API some time to save the recoding file for the call.
    response = await changeStatusVoiceCall(callInfo);
    res.status(201).json(response);
}

/**
 * Handle incoming voice call using Twilio API.
 * @category CallsController
 * @author jlbciriaco[at]gmail.com
 * @return {XMLDocument}      The TwiML who controls the conversation flow.
 */
export const receiveCall = async (req, res) => {
    const voiceCallResponse  = await receiveVoiceCall();

    res.header("Content-Type", "application/xml");
    res.status(200).send(voiceCallResponse);
};

/**
 * Get all voice calls captured by the system
 * @category CallsController
 * @author jlbciriaco[at]gmail.com
 * @return {Response}      Status and content for the voice calls fetching.
 */
export const getAllVoiceCalls = async (req, res) => {
    let voiceCalls  = await getVoiceCalls();

    const response = {
        "status": true,
        "message": "Data successfully retrieved",
        "content": voiceCalls
    }

    res.status(200).json(response);
}

/**
 * Handle the websocket feature for voice calls, particularly the audio streaming.
 * @category CallsController
 * @author jlbciriaco[at]gmail.com
 * @param  {Number} textID The ID for the text desired to stream
 */
export const handleAudioStream = async (ws, req) => {
    const deepgramClient = createClientDeepgram(constants.AUTH_TOKEN_DEEPGRAM);

    let textID = parseInt(req.params.id_text);

    /* 
        If request is not for unanswered/reminder calls audio streaming, 
        close the connection. 
    */

    if(![1,2].includes(textID)){
        ws.close();
        return;
    }

    let keepAlive;
    let patientTextResponse = "";

    const setupDeepgram = () => {
        const deepgram = deepgramClient.listen.live({
            language: "en",
            smart_format: true,
            model: "nova",
            encoding: "mulaw",
            sample_rate: 8000,
            channels: 1,
        });
    
        if (keepAlive) clearInterval(keepAlive);
            keepAlive = setInterval(() => {
            console.log("deepgram: keepalive");
            deepgram.keepAlive();
        }, 10 * 1000);
    
        deepgram.addListener(LiveTranscriptionEvents.Open, async () => {
            deepgram.addListener(LiveTranscriptionEvents.Transcript, (data) => {
                patientTextResponse += data.channel.alternatives[0].transcript;
                console.log(patientTextResponse);
            });
        
            deepgram.addListener(LiveTranscriptionEvents.Close, async () => {
                clearInterval(keepAlive);
                deepgram.requestClose();
            });
        
            deepgram.addListener(LiveTranscriptionEvents.Error, async (error) => {
                console.error(error);
            });
        
            deepgram.addListener(LiveTranscriptionEvents.Warning, async (warning) => {
                console.warn(warning);
            });
        
            deepgram.addListener(LiveTranscriptionEvents.Metadata, (data) => {
                console.log("deepgram: packet received");
                console.log("deepgram: metadata received");
            });
        });
        
        return deepgram;
    };
    
    let hearPatientResponse = false;
    let deepgramInstance = setupDeepgram();

    ws.on('message', async (data) => {
        if(!isJsonString(data)){
            return;
        }

        const message = JSON.parse(data);
        let stopMessageSending = false;
        let response = "";
        
        if( message.event == "mark" ){
            if( message.mark.name == "stoppedPlaying" ) {
                hearPatientResponse = true;
            }
        }
        
        if(hearPatientResponse){
            if( message.event == "media" && message.media ) {
                if(message.media.track == "inbound"){
                    const rawAudio = Buffer.from(message.media.payload, "base64");
                    deepgramInstance.send(rawAudio);
                }
            }
        }
        
        if(message.event == "start"){
            const streamSid = message.start.streamSid;

            await generateVoiceTTS(textID)
            .then((data) => {response = data})
            .catch((err) => {stopMessageSending = true});
            
            if(stopMessageSending) {
                return;
            }
            
            const readableStream = Readable.from(response);
            const audioArrayBuffer = await streamToArrayBuffer(readableStream);
    
            ws.send(
                JSON.stringify({
                    streamSid,
                    "event": 'media',
                    "media": {
                        payload: Buffer.from(audioArrayBuffer).toString('base64'),
                    },
                })
            );

            ws.send(
                JSON.stringify({
                    streamSid,
                    "event": 'mark',
                    "mark": {
                        "name": "stoppedPlaying",
                    },
                })
            );
        }
        
    });

    ws.on('close', () => {
        deepgramInstance.requestClose();
        deepgramInstance.removeAllListeners();
        deepgramInstance = null;
    });

    ws.on('error', () => {
        deepgramInstance.requestClose();
        deepgramInstance.removeAllListeners();
        deepgramInstance = null;
        ws.close();
    });
}